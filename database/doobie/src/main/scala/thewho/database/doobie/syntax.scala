package thewho.database.doobie;

import doobie.implicits._
import doobie.util.Read
import doobie.util.fragment.Fragment
import doobie.util.transactor.Transactor
import thewho.error.DatabaseException
import thewho.error.DatabaseException.{ DatabaseDefect, DatabaseError }
import zio.interop.catz._
import zio.{ IO, Task }

trait syntax {

  protected def _xa: Transactor[Task]

  type UpdatedRowsCount = Int

  implicit class FragmentSyntax(fragment: Fragment) {

    /**
     * Run the sql query succeeding with an Option.
     *
     * @tparam A The type of the value returned inside the Option
     */
    def _query[A: Read]: IO[DatabaseDefect, Option[A]] =
      fragment.query[A].option.transact(_xa) mapError DatabaseDefect

    /**
     * The same as [[_query]] but with a default value in the error channel or
     * the unwrapped result in the success channel.
     *
     * @param error The default value for th error channel
     * @tparam A The type of the value returned in the success channel
     */
    def _queryAndIfEmpty[A: Read](error: DatabaseError): IO[DatabaseException, A] =
      _query[A] >>= fromOption(error)

    /**
     * Run the sql query returning the number of rows affected.
     */
    def _update: IO[DatabaseDefect, UpdatedRowsCount] =
      fragment.update.run.transact(_xa) mapError DatabaseDefect

    /**
     * The same as [[_update]] but failing with the provided error if no rows were affected.
     *
     * @param error The error in case of no rows affected
     */
    def _updateAndIfNoHits(error: DatabaseException): IO[DatabaseException, UpdatedRowsCount] =
      _update >>= ifNoHits(error)

    /**
     * Run the sql query returning the key of the value generated by the database.
     *
     * @tparam A The type of the generated key
     */
    def _create[A: Read]: IO[DatabaseDefect, A] =
      fragment.update.withUniqueGeneratedKeys[A]("id").transact(_xa) mapError DatabaseDefect

  }

  private def fromOption[A](ifEmpty: DatabaseError)(option: Option[A]): IO[DatabaseError, A] =
    option.fold[IO[DatabaseError, A]](IO fail ifEmpty)(a => IO succeed a)

  private def ifNoHits(
    error: DatabaseException
  )(updatedRowsCount: UpdatedRowsCount): IO[DatabaseException, UpdatedRowsCount] =
    updatedRowsCount match {
      case 0 => IO fail error
      case i => IO succeed i
    }

}
